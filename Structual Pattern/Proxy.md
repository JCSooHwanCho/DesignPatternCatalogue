# 프록시(Proxy) - 객체 구조

* 의도: 다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리채움자 역할을 하는 객체를 둔다.
* 다른 이름: 대리자(Surrogate)
* 동기: 생성이나 관리 비용이 큰 객체를 꼭 필요할 때만 생성하고 싶은데, 이것을 감추기 위해 그 빈자리를 대신하는 역할이 필요하다.
* 활용성 : 단순한 포인터보다 좀더 정교한 참조 규칙을 적용할 수 있다.
	* 원격지 프록시(remote proxy): 서로 다른 주소공간에 존재하는 객체를 대리하는 객체
	* 가상 프록시(virtual proxy): 요청이 있을 때만 필요한 고비용 객체를 생성한다.
	* 보호용 프록시(protection proxy): 원래 객체에 대한 실제 접근을 제어한다. -> 객체별로 접근 권한이 다를 때 유용하다.
	* 스마트 참조자(smart reference): 원시 포인터의 대체 객체
		* 실제 객체의 참조 횟수를 저장해놓고 참조횟수가 0이되면 자동해제(스마트 포인터)
		* 맨 처음 참조되는 시점에, 객체를 저장소에서 메모리로 옮긴다.
		* 실제 객체에 접근하기 전에, lock을 건다.
* 구조
  ![Proxy](/img/Proxy.JPG)
  ![ProxyModel](/img/ProxyModel.JPG)
* 참여자
	* Proxy
		* 실제로 참조할 대상에 대한 참조자를 갖는다. 
		* Subject와 동일한 인터페이스를 제공한다.
		* 실제 대한에 대한 접근을 제어하고, 실제 대상의 생성과 삭제를 책임진다.
		* 프록시 종류에 따라 별도의 추가 작업을 수행한다.
			* 원격지 프록시 : 요청 메시지와 인자를 인코딩하여 다른 주소공간의 실제 대상에게 전달한다.
			* 가상 프록시: 실제 대상에 대한 추가적인 정보를 보유하여 실제 접근을 지연한다.
			* 보호용 프록시: 요청한 대상이 실제 권한이 있는지 확인한다.
	* Subject: Realsubject와 Proxy에 공통적인 인터페이스를 정의하여, RealSubject가 요청되는 곳에 Proxy를 사용할 수 있게 한다.
	* RealSubject: 실제 객체
* 협력 방법: 프록시는 자신이 받은 요청을 실제 객체에 전달한다.
* 결과
	* 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공한다.
		* 원격지 프록시: 객체가 다른 주소 공간에 있다는 것을 숨길 수 있다.
		* 가상 프록시: 처리를 최적화 할 수 있다.
		* 보호용 프록시 & 스마트 참조자: 객체 접근시의 추가 관리를 책임진다.
	* Copy-on-Write의 적용이 가능해진다. -> 원본의 참조 카운트 관리가 반드시 필요하다.
* 구현
	* (C++)멤버 접근 연산자를 오버로드한다.
	* (smalltallk) doesNotUnderstand 메소드를 오버라이드한다 -> 아무 메시지도 이해할 수 없는 클래스를 정의해서, 모든 메시지가 doesNotUnderstand 메소드를 호출하도록 한다.
	* 프록시가 항상 실제 대상을 알 필요는 없다. -> 다만 , 생성시에는 반드시 실제 클래스를 알아야만 한다.
* 관련 패턴
	* 적응자 패턴: 실제 객체의 사이에 끼인다는 공통점이 있음
	* 장식자 패턴: 구현방법이 비슷하나 목적이 다름(기능 추가 vs 접근 제어) -> 실제로는 보호성 프록시만 유사하고 나머지는 차이가 있다.