# 복합체(Composite) - 객체 구조

* 의도: 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성한다. -> 개별 객체와 복합 객체를 동일하게 다룰 수 있도록 한다.
* 동기: 간단한 요소들을 합쳐 더 큰 요소를 만드는데, 간단한 요소와 큰 요소를 구분하지 않고 동일하게 취급하고 싶다.
* 활용성
	* 부분 - 전체의 객체 계통을 표현하고 싶을 때
	* 사용자가 복합 구조의 모든 객체를 똑같이 취급하도록 하고 싶을 때
* 구조
   ![Composite](/img/Composite.JPG)
   ![Composite](/img/CompositeHierarchy.JPG)
* 참여자
	* Component : 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의한다. 
		* 모든 클래스에 해당하는 인터페이스는 공통의 행동을 구현한다.
		* 전체 클래스에 속한 요소들을 관리하는 인터페이스를 정의한다.
		* (필요하다면) 재귀적인 구조에서 부모 컴포넌트로 접근하는 인터페이스를 정의하고, 적절하다면 구현까지 한다.
	* Leaf: 자식 요소가 없는 가장 기본적인 요소들
	* Composite :  자식 요소가 있는 요소들. 자식 요소들을 내부에 저장하고, 자식과 관련된 인터페이스를 구현한다.
	* Client: Component 인터페이스를 통해 복합 구조 내의 객체들을 조작한다.
*  협력 방법
	* 복합 구조 내 객체 간의 상호작용을 위해 Component 클래스 인터페이스를 사용한다. 요청 대상이 Leaf면 작업을 직접 수행하고.  Component면 자식 객체들에게 요청을 위임한다. 위임하기 전후에 다른 처리를 수행할 수도 있다.
* 결과
	* 기본 객체 + 복합 객체로 구성된 하나의 일관된 클래스 계통이 정의된다. -> 사용자는 이를 구분하지 않고 하나의 클래스 인터페이스를 이용해 이들을 다룰 수 있다.
	* 사용자의 코드가 단순해진다. -> 단순 객체와 복합 객체를 구분하기 위한 분기문이 필요없어지기 때문
	* 새로운 종류의 구성요소를 쉽게 추가할 수 있다.
	* 다만 설계나 지나치게 범용적이게 되어, 새로운 제약을 추가하는 것은 어려워진다.
* 구현
	* 포함 객체에 대한 명확한 참조자 -> 구조를 거슬러 올라가거나, 요소를 하나 삭제하는 과정을 단순화시킨다.
		* 참조자는 주로 Component 클래스에 둔다.
	* 구성요소 공유 -> 메모리 소모량을 줄일 수 있다.
		* 구성요소의 부모가 한개 이상이라면 공유하기가 어렵다.
		* 여러 부모를 가지게 할 수도 있지만, 어떤 부모에게 메시지를보낼 지가 애매해질 수 있습니다.
		* 자식이 자기의 상태를 공개해서  부모에게 메시지를 보내지 않을 수 있다면, 플라이급 패턴을 이용해서 부모를 저장하지 않고도 설계를 개선할 수있다. 
	* Component 인터페이스를 최대화 -> Composite와 Leaf가 가질 수 있는 모든 인터페이스를 선언해야 한다!
		* Component 단위에서만 의미있는 연산에 대해서는  Leaf가 아무것도 수행하지 않도록 한다.
	* 자식을 관리하는 인터페이스 선언 : 안정성과 투명성 사이의 trade-off
		* Component에 정의 : 투명성 획득 가능, Leaf에서 해당 연산이 의미가 없기 때문에 이를 호출하지 않아야 함.(안정성 하락)
		* Composite에만 정의: 안정성을 보장 받으나, Composite와 Leaf를 동일한 요소로 보기 어려워짐(투명성 하락)
	* Component가 Component의 리스트를 구현할 수 있는가? -> 자식들 리스트를 가질 수 있도록 할 수 있지만, Leaf 클래스도 이를 위해 메모리를 추가로 가져야 한다. 자식이 정말 많아서 탐색 속도가 문제가 될 때쯤에야 고려할만 한다.
	* 자식 사이의 순서 정하기 : 자식 사이의 순서가 의미있고 문제가 될때, 자식을 관리하는 인터페이스를 설계할 때 이를 관리할 수 있도록 주의를 기울여야 한다 -> 반복자 패턴이 도움을 줄 수 있다.
	* 성능 개선을 위한 캐싱: 구조 순회가 자주 일어난다면, 이 결과를 미리 캐싱해 놓을 수 있다. 
		* 캐싱을 이용하려면 현재 캐싱 정보가 유효한지 아닌지를 확인해야 한다.
	* 누가 구성요소를 삭제하는가?: 가비지 컬렉션이 없으면 Composite 클래스가 책임을 진다. 다만 Leaf 객체가 불변이거나 공유 객체라면 이것이 불가능하다.
	* 구성요소를 저장하기 위해 가장 적당한 데이터 구조를 판단해야 한다.
* 관련 패턴
	* 책임 연쇄 패턴: 구성요소-부모간의 연결에 복합체 패턴이 많이 사용된
	* 장식자 패턴: 복합체 패턴과 함께 사용되는 경우가 많다.
	* 플라이급 패턴: 구성요소의 공유방법을 제시해준다. 단, 공유되는 구성요소의 부모는 참조할 수 없다
	* 반복자 패턴 : 구성 요소의 순회방법을 제시해준다
	* 방문자 패턴 : Composite와 Leaf에 걸쳐 분산될 수 있는 행동을 국소화 시킬 수 있다