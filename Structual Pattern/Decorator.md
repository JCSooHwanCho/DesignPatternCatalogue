# 장식자(Decorator) - 객체 구조

* 의도 : 객체에 동적으로 새로운 책임을 추가할 수 있게 한다. 기능을 추가하려할 때, 좀 더 융통성 있는 방법을 제공한다.
* 다른 이름 : 랩퍼(Wrapper)
* 동기 : 전체 클래스에 새로운 기능을 추가할 필요는 없지만 개별 클래스에 새로운 책임을 추가할 필요가 있을 때 -> 다른 객체가 이를 감싸게 하고,  이 둘러싼 객체는 자신이 감싼 객체의 인터페이스를 동일하게 제공한다.
* 활용성 
	* 동적이고 투명하게 개별 객체에 새로운 책임을 추가하기 위해 사용한다.
	* 제거될 수 있는 책임에 대해 사용한다.
	* 실제 상속으로 서브클래스를 계속 만드는 방법이 실질적이지 못하다.
* 구조
    ![Decorator](/img/Decorator.JPG)
* 참여자
	* Component: 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스 -> 이 인터페이스를 이용해 객체를 사용하게 된다.
	* ConcreteComponent: 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체
	* Decorator: 객체에 대한 참조자를 관리하면서 Component에 정의된 인터페이스를 만족하도록 자체 인터페이스 정의
	* ConcreteDecorator: Component에 새롭게 추가할 서비스를 실제로 구현하는 클래스
* 협력 방법 : Decorator는 자신의 Component 객체 쪽으로 요청을 전달한다. 요청 전달 전후로 자신만의 추가 연산을 선택적으로 수행할수도 있다.
* 결과
	* 단순한 상속보다 설계의 융통성을 더 많이 증대시킬 수 있다. -> 책임의 조합이 동적이게 되기 때문
	* 클래스 계통의 상부에 많은 기능이 누적되는 것을 피할 수 있다.
	* 장식자와 해당 장식자의 구성요소는 동일하지 않다.
	* 작은 규모의 클래스가 많아져서 복잡해질 수 있다.
* 구현
	* 인터페이스 일치시키기 -> 자신이 둘러싸고 있는 구성요소의 인터페이스를 만족해야한다.
	* 추상 클래스로 정의되는 Decorator 클래스 생략하기 -> Decorator에 정의할 책임이 하나뿐인 경우, concreteDecorator와 합칠 수 있다.
	* Component 클래스는 가벼운 무게를 유지하기 
		* 무언가 저장하는 변수는 없어야 한다.
		* 너무 많은 서비스를 가지는 것도 지양해야 한다.
	* 객체의 겉포장을 변경할 것인가, 속을 변경할 것인가 -> 속을변경한다면 전략 패턴(Strategy)을 고려할 수 있다.
* 관련 패턴
	* 적응자 패턴 : 장식자를 객체의 책임, 행동을 변화시키는 적응자로 볼 수 있다.
	* 복합체 패턴 : 장식자를 한 구성 요소만을 갖는 복합체로 볼 수 있다. 대신 목적은 객체에 새로운 행동을 추가하기 위한 것이다.
	* 전략 패턴 : 객체를 변경하는 두 가지 다른 대안이다.