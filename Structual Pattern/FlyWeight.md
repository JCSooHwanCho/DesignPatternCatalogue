# 플라이급(Flyweight) - 객체 구조 
* 의도 : 공유를 통해 많은 수의 소립(fine-grained) 객체들을 효과적으로 지원한다.
* 동기:  본질적인 것과 부가적인 것을 분리하여, 처리해야 하는 데이터량을 줄이고 싶다.
* 활용성 
	* 응용프로그램이 대량의 객체를 사용해야 할 때
	* 객체의 수가 너무 많아 저장 비용이 너무 높아질 때
	* 대부분의 객체 상태를 부가적인 것으로  만들 수 있을 때
	* 부가적인 속성들을 제거하면, 대부분을 공유 객체로 대체할 수 있을 때 -> 본질은 같은데, 부가 정보만 다를 때
	* 응용프로그램이 객체의 정체성에 의존하지 않을 때
* 구조
  ![Flyweight](/img/Flyweight.JPG)
  ![FlyweightModel](/img/FlyweightModel.JPG) 
* 참여자
	* FlyWeight: FlyWeight가 받아들일 수 있고, 부가적 상태에서 동작할 수 있는 인터페이스를 선언한다.
	* ConcreteFlyweight : Flyweight 인터페이스를 구현하고 내부적으로 갖고 읽어야 하는 본질적 상태에 대한 저장소를 정의한다. -> 공유가 가능하며, 그렇기에 본질적인 것만 담아야 한다.
	* UnsharedConcreteFlyweight: 공유를 하지 않는 ConcreteFlyweight
	* FlyweightFactory: 플라이급 객체를 생성하고 관리하며, 플라이급 객체가 제대로 공유되도록 보장한다.
	* Client: 플라이급 객체에 대한 참조자를 관리하고, 부가적 상태를 저장한다.
* 협력 방법
	* 사용자가 연산을 호출할 때 자신에게만 필요한 부가적 상태를 플라이급 객체에 매개변수로 전달한다.
	* ConcreteFlyweight를 FlyweightFactory를 통해서 공유한다.
* 결과
	* 공유하는 인스턴스의 전체 수를 줄인다.
	* 객체별 본질적 상태의 양을 줄일 수 있다.
	* 부가적인 상태는 연산되거나 저장할 수 있다.
	* 본질적인 상태를 저장하는 비용은 줄지만, 부가 정보를 만들고 사용하는 비용이 새로 생긴다.
	* 복합체 패턴과 조합하여,
* 구현
	* 부가적 상태를 제외한다.
	* 공유할 객체를 관리한다.
* 관련 패턴
	* 복합체 패턴 :  조합해서 계층 구조를 모델링하는데 사용 -> 노드들은 자신의 부모 포인터를 저장할 수 없기 때문에, 부모 포인터를 부가적 상태의 일부로 플라이급 객체에다 넘겨야한다.
	* 상태 패턴
	* 전략 패턴