# 해석자(Interpreter) - 클래스 행동

* 의도: 어떤 언어에 대해, 그 언어의 문법에 대한 표현을 정의하면서 이를 통해 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의한다.
* 동기: 특정 문제를 해결하는 별도의 표현체계를 도입할 필요가 있다 (정규표현식 등)
* 활용성: 해석이 필요하거나, 추상 구문 트리로서 그 언어의 문장을 표현하고자 할 때
		* 정의할 언어의 문법이 간단할 때 사용할 수 있다. -> 복잡하면 파서 생성기 같은 도구를 쓰는 게 더 낫다
		* 효율성은 큰 고려 대상이 아니다. 가장 효율적인 방법은 파스트리를 직접 해석하는 게 아니라 이를 빠르게 해석할 수 있는 다른 형태로 변형하는 것인데, 이에 쓸 번역기를 만들 때도 해석자 패턴을 적용할 수 있다.
* 구조
  ![Interpreter](/img/Interpreter.JPG)
* 참여자
	* AbstractExpression: 추상 구문 트리에 속한 모든 노드에 해당하는 클래스들이 공통으로 가져야 할 Interpret() 연산을 추상 연산으로 정의한다.
	* TerminalExpression: 문법에 정의한 터미널 기호와 관련된 해석 방법을 구현한다. 모든 터미널 기호에 대해 해당 클래스를 만들어야 한다.
	* NonterminalExpression: 터미널 기호가 아닌 모든 기호에 대한 클래스
	* Context: 번역기에 대한 포괄적인 정보
	* Client: 추상 구문 트리. Nonterminal + terminal 로 이루어지며, 이 클래스의 Interpret()을 호출하면서 해석이 된다.
* 협력 방법
	* 사용자는 추상 구문 트리를 구성한다. -> Interpret()을 호출하면서, 해석에 필요한 문맥 정보를 초기화한다.
	* NonterminalExpression은 재귀적으로 Interpret()을 호출하며 전체를 해석해 나간다.
	* Interpret()은 해석자의 상태를 저장하거나 상태를 알기 위해 문맥을 활용한다.
* 결과
	* 문법의 변경과 확장이 쉽다. -> 상속을 이용해 기존 표현식을 수정하거나, 새로운 표현식을 정의할 수 있다.
	* 문법의 구현이 용이하다. -> 추상 구문 트리의 노드 클래스들은 비슷한 구현을 갖는다.
	* 복잡한 문법은 관리가 어렵다. -> 복잡한 문법은 컴파일러 생성기나 파서 생성기를 사용하는 것이 바람직.
	* 표현식을 해석하는 새로운 방법을 추가할 수 있다. -> 추가가 잦다면, 방문자 패턴을 쓰는 게 좋다.
* 구현 -> 복합체 패턴과 겹치는 게 많다. 아래는 해석자 패턴에 국한된 내용
	* 추상 구문 트리 생성 -> 테이블을 이용한 파서로 만들거나, 재귀 하향식 파서를 직접 구현해야 한다.
	* Interpret() 연산을 정의한다. -> 새로운 해석자를 생성하는 게 바람직하다면, 방문자 클래스를 이용해서 이 방문자 클래스가 해석을 담당하는 게 좋다.
	* 플라이급 패턴을 적용하여 단말 기호를 공유한다
* 관련 패턴
	* 복합체 패턴: 추상 구문 트리는 복합체 패턴으로 볼 수 있다.
	* 플라이급 패턴: 하나의 구문 트리 내에 터미널 기호를 여러 개 공유할 때 사용한다.
	* 방문자 패턴: 구문 트리 각 노드에 대한 상태를 관리할 수 있다.