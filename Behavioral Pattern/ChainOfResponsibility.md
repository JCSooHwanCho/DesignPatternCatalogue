# 책임 연쇄(Chain of Responsibility) - 객체 행동

* 의도: 메시지는 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴. 하나의 요청에 대한 처리가 반드시 한 객체에서만 일어나지 않고, 여러 객체에게 기회가 주어진다.
* 동기: 요청을 보내는 객체가 실제 요청을 처리해야 할 객체를 특정할 수 없을 때, 객체 연결 고리를 따라가면서 이 요청을 처리할 수 있는 객체를 찾고 싶다.
* 활용성
	* 하나 이상의 객체가 요청을 처리해야하고, 그 요청 처리자 중 어떤 것이 선행자(priori)인 지 알 수 없을 때
	* 메시지를 받을 객체를 명시하지 않은 채, 여러 객체 중 하나에게 처리를 요청하고 싶을 때
	* 요청을 처리할 수 있는 객체 집합을 동적으로 정의해야 할 때
* 구조
  ![ChainOfResponsibility](/img/ChainOfResponsibility.JPG)
  ![ResponsibilityChain](/img/ResponsibilityChain.JPG)
* 참여자
	* Handler : 요청을 처리하는 인터페이스를 정의하고, 후속 처리자와의 연결을 구현한다.
	* ConcreteHandler : 책임져야 할 행동은 처리하고, 그렇지 않으면 후속 처리자에게 처리를 요청한다.
	* Client: ConcreteHandler에게 필요한 요청을 보낸다.
* 협력 방법
	* 사용자는 처리를 요청하고, 이 요청은 그 요청을 처리할 ConcreteHandler를 만날 때 까지 정의된 연결 고리를 따라서 계속 전달된다.
* 결과
	* 객체 간의 행동적 결합도가 적어진다. -> 객체간의 상호과정을 단순화시킨다. 요청을 하는 객체는 요청을 처리할 후보들을 다 알 필요가 없이, 자신과 연결된 객체 하나만 알면 된다.
	* 객체에게 책임을 할당하는 데 유연성을 높일 수 있다.
	* 메시지 수신을 보장할 수는 없다. -> 처리되지 못한 요청은 버려진다.
* 구현
	* 후속 처리자들의 연결 고리 구현 -> 별도의 연결 고리를 만들거나, 기존의 계층 정보가 있다면 이를 사용한다.
	* 후속 처리자 연결하기 -> 후속 처리자에 대한 정보를 클래스 내부에 저장한다. 해당 클래스에서 처리할 게 없으면 이 후속자에 요청을 넘겨준다.
	* 처리 요청의 표현부를 정의한다. -> 요청을 캡슐화해서, 다양한 요청을 해당 객체를 통해 넘길 수 있게 만든다.
	* (스몰토크) 자동 전달기능 이용
* 관련 패턴
	* 복합체 패턴 : 대부분 함께 사용된다. 이때 구성 요소의 부모는 후속 처리자처럼 동작한다.