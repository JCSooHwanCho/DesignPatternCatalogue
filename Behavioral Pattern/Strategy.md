# 전략(Strategy) -  객체 행동
* 의도: 동일 계열의 알고리즘군을 정의하고, 각 알고리즘을 캡슐화하여 상호 교환이 가능하도록 만든다. 클라이언트와 독립적으로 알고리즘을 변경할 수 있게 한다.
* 다른 이름: 정책(Policy)
* 동기: 알고리즘을 사용자 코드에 하드코딩하는 것은 바람직하지 않기 때문에, 이를 캡슐화할 필요가 있다.
* 활용성
	* 행동적으로 조금씩만 다르고 개념상으로는 관련성이 큰 클래스가 많이 있을 때
	* 알고리즘의 변형이 필요할 때
	* 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때
	* 하나의 클래스가 많은 행동을 정의하고, 이런 행동들이 그 안에서 복잡한 다중 조건문의 모습을 취할 때
* 구조
  ![Strategy](/img/Strategy.JPG) 
* 참여자
	* Strategy: 제공하는 모든 알고리즘에 대한 공통의 연산들을 인터페이스로 정의
	* ConcreteStrategy: Strategy 인터페이스를 실제 알고리즘을 구현
	* Context: Strategy 객체의 참조자를 관리하고, Strategy가 자료에 접근하기 위한 인터페이스를 정의
* 협력 방법
	* Context가 알고리즘에 해당하는 연산이 호출되면, 필요한 데이터(혹은 Context 자체)를 모두 Strategy 객체로 보낸다.
	* 사용자는 ConcreteStrategy를 만들어 Context에 전달한다.
* 결과
	* 동일 계열의 관련 알고리즘군이 생긴다 -> 알고리즘 자체의 재사용이 가능해진다.
	* 서브클래싱의 대안이 된다 -> Context와 알고리즘을 분리하여, 알고리즘만 다른 여러 클래스가 생기는 것을 막을 수 있다.
	* 조건문을 없앨 수 있다.
	* 구현의 선택이 가능하다.
	* 사용자가 서로 다른 Strategy을 모두 알아야 하는 부담이 생긴다.
	* Strategy와 Context간의 통신에서 오는 오버헤드가 있다.
	* 객체 수가 증가한다. -> 상태가 없으면 이를 공유하는 것도 가능하다.
* 구현
	* Strategy 및 Context 인터페이스를 정의한다 -> 서로에게 필요한 정보를 효율적으로 접근할 수 있는 인터페이스를 정의해야 한다.
	* 전략을 템플릿 매개변수로 사용한다. -> Strategy를 컴파일 타임에 결정할 수 있고 이를 바꿀 필요가 없을 때
	* Strategy 객체에 선택성을 부여한다. -> 기본 구현을 제공해서, Strategy 객체를 쓰지 않게 할 수도 있다.
* 관련 패턴
	* 플라이급 패턴: Strategy 객체들의 규모가 작으므로, 플라이급 패턴을 쓰는 게 좋다.