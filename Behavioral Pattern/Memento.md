# 메멘토(Memento) - 객체 행동

* 의도: 캡슐화를 위배하지 않은 채, 어떤 객체의 내부 상태를 잡아내고 실체화시켜 둠으로써, 이후 해당 객체가 그 상태로 되돌아올 수 있도록 한다.
* 다른 이름: 토큰(Token)
* 동기: 객체 상태를 되돌리기 위해서는 상태를 잡아내야 하는데,  이것은 캡슐화를 깨는 일이다. -> 메멘토 객체를 만들고, 원래 객체만 이를 참조 할 수 있도록 만들면 캡슐화가 유지될 수 있다.
* 활용성
	* 어떤 객체의 상태에 대한 스냅샷(일부분)을 저장한 후 나중에 이 상태로 복구해야 할 때
	* 상태를 얻는데 필요한 직접적인 인터페이스를 두면 그 객체의 구현 세부사항이 드러나버리고, 이것으로 캡슐화가 깨질 때
* 구조
  ![Memento](/img/Memento.JPG) 
* 참여자
	* Memento: 원조본 객체의 내부 상태를 저장한다.(필요한 만큼) Caretaker에게는 일부 인터페이스만 노출하고, Originator에게는 더 다양한 인터페이스를 노출한다.
	* Originator: 원조본 객체
	* Caretatker: 메멘토의 보관을 책임지는 객체. 메멘토의 내용을 검사하거나 건드리지는 않는다.
* 협력 방법
	* 보관자 객체는 원조본 객체에 메멘토 객체를 요청한다. 이 때 요청한 시간을 저장하고, 받은 메멘토 객체를 다시 원조본 객체에게 돌려준다.(만약 되돌릴 필요가 없는 경우에는 전달이 안될 수도 있다.)
	* 메멘토 객체는 수동적이다. 원조본만이 상태를 설정하고 읽어올 수 있다.
	![MementoInteraction](/img/MementoInteraction.JPG) 
* 결과
	* 캡슐화된 경계를 유지할 수 있다.
	* Originator클래스를 단순화할 수 있다.
	* 메멘토의 사용이 더 많은 비용을 불러올 수도 있다. -> Originator의 정보량이 너무 많거나,  메멘토 반환이 지나치게 자주 일어나는경우 -> 상태 저장과 복구 비용이 크면 적합하지 않다.
	* 제한 범위 인터페이스와 광범위 인터페이스를 정의해야한다 -> 일부언어에서는 어려울 수도 있다.
	* 메멘토 관리 비용이 숨어있을 수 있다.
* 구현
	* 언어의 지원여부 ->  C++의 friend기능을 쓰면 광범위 인터페이스를 제공하는 셈이된다.
	* 점증적 상태 변경을 저장한다. 모든 상태를 곧이곧대로 저장하는 것은 비효율적이다.
* 관련 패턴
	* 명령 패턴: 실행취소가 가능한 연산의 상태를 저장할 때 사용 가능
	* 반복자 패턴: 반복 과정 상태를 관리할 수 있다.