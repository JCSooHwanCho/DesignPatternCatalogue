# 반복자(Iterator) - 객체 행동

* 의도: 내부 표현부를 노출하지 않고 어떤 집합 객체에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공한다.
* 다른 이름: 커서(Cursor)
* 동기: 내부 표현 구조나 알고리즘이 바뀌어도 동일한 인터페이스로 순회하는 방법을 제공하고 싶다.
* 활용성
	* 객체 내부 표현 방식을 모르고도 집합 객체의 각 원소들에 접근하고 싶다.
	* 집합 객체를 순회하는 다양한 방법을 지원하고 싶다.
	* 서로 다른 집합 객체 구조에 대해서도 동일한 방법으로 순회하고 싶다.
* 구조
  ![Iterator](/img/Iterator.JPG)
* 참여자
	* Iterator: 원소를 접근하고 순회하는 데 필요한 인터페이스
	* ConcreteIterator: Iterator를 구현한 클래스. 현재 위치를 기억함
	* Aggregate: Iterator 객체를 생성하는 인터페이스 정의
	* ConcreteAggregate: Aggregate를 구현 -> 해당하는 ConcreteIterator 구현
* 협력 방법 : ConcreteIterator는 집합 객체 내 현재 객체를 계속 추적하고 다음번 방문할 객체를 정한다.
* 결과
	* 집합 객체의 다양한 순회 방법을 제공한다.
	* Aggregate 클래스의 인터페이스를 단순화한다. -> 순회방식에 따라 여러 인터페이스를 제공할 필요가 없기 때문에
	* 2가지 이상의 순회 방식을 제공할 수 있다.
* 구현
	* 누가 반복을 제어하게 할까?  사용자(외부 반복자) vs 반복자 자체(내부 반복자)
	* 순회 알고리즘을 어디서 정의할 것인가? Iterator vs Aggregate(커서) -> Aggregate에는 현재 위치만 저장하고, Next() 연산으로 커서를 움직인다.
	* 어떻게 반복자를 견고하게 만들 수 있을까? -> 순회중에 삽입이나 삭제가 일어나지 않아야 하고, 집합 객체를 복사하지 말아야 한다. -> 집합 객체에 반복자를 등록하는 방법을 취한다.
	* 추가적으로 필요한 연산: 앞으로 돌아가는 연산, 특정 인덱스로 점프 등....
	* C++에서 다형성을 지닌 반복자: 런타임 비용 때문에, 꼭 필요할 때만 쓰는 게 좋다. 아니면 확장된 반복자를 쓰는게 더 낫다.
		* 다형성 반복자는 사용자가 직접 반복자를 삭제하는 책임을 져야하는 문제가 있다 -> 프록시를 적용할 수 있다.
	* 반복자에는 특수한 접근 권한이 있다 -> 다만 이러면 새로운 순회 방법 정의가 어렵다, 이를 해결하기 위해 Iterator의 protected 영역에 특권적인 연산을 정의하고, Iterator의 서브클래스들은 이것을 사용하여 특권을 누릴 수 있다.
	* 복합체를 위한 반복자: 외부 반복자는 재귀적 합성 구조를 처리하기는 어렵다. 하지만 내부반복자는 이를 자체적으로 관리하기 때문에 적용하기 좋다.
	* Null 반복자: 순회를 시도하면 바로 끝나는 반복자. 트리의 단말에서 이를 반환하게 하면, 일관적인 트리 탐색을 구현할 수 있게 됨
* 관련 패턴
	* 복합체 패턴: 재귀적 구조가 있어 반복자를 쓰기 좋다.
	* 팩토리 매소드 패턴: 다양한 반복자를 사용할 때, 적절한 반복자를 얻는데 적용할 수 있다.
	* 매멘토 패턴: 반복자 자신이 반복한 결과를 저장하기 위해 사용한다.