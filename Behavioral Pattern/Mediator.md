# 중재자(Mediator) - 객체 행동

* 의도: 한 집합에 속해있는 객체의 상호작용을 캡슐화하는 객체를 정의한다. 객체 사이의 결합성을 낮추며, 상호작용을 독립적으로 다양화 시킬 수 있다.
* 동기: 여러개로 분할된 객체들의 상호작용이 너무 복잡해졌고, 결합성이 너무 커져서 이를 낮추고 싶다. -> 상호작용도 캡슐화하자!
* 활용성
	* 여러 객체가 잘 정의되어있지만, 복잡한 상호작용 과정을 가질 때. 
	* 객체간 의존성이 구조화되지 않으며, 이해하기 어려울 때
	* 한 객체가 다른 객체를 너무 많이 참조하고, 너무 많은 의사소통을해서 재사용이 힘들 때
	* 여러 클래스에 분산된 행동들을 상속 없이 상황에 맞게 수정해야 할 때
* 구조
  ![Mediator](/img/Mediator.JPG)
  ![MediatorModel](/img/MediatorModel.JPG) 
* 참여자
	* Mediator: Colleague 객체와 교류하는 데 필요한 인터페이스를 정의한다.
	* ConcreteMediator:  Colleague 객체와 조화를 이뤄서 협력 행동을 구현하고, 자신이 맡을 동료객체(Colleague)를 파악하고 관리한다.
	*  Colleague 클래스들: 자신의 중재자 객체가 무엇인지 파악하고, 다른 객체와의 통신이 필요하면 그 중재자를 통해 통신되도록 한다.
* 협력방법
	* Collegue는 Mediator를 통해 요청을 보내고 받는다.
* 결과
	* 서브클래싱의 횟수를 제한한다. 새로운 행동이 필요하면 Mediator만 바꾸면 된다.
	* Colleague 객체 사이 종속성을 줄인다.
	* 객체 프로토콜을 단순화 한다. N:N에서 1대1로.
	* 객체 간의 협력 방법을 추상화 한다. -> 객체 자체를 크게 고려하지 않고 연결에만 집중할 수 있다.
	* 통제 집중화, 때로는 Mediator 클래스의 유지보수가 어려워질 수도 있다.
* 구현
	* ConcreteMediator가 하나만 있어도 되면 추상 클래스인 Mediator 생략해도 된다.
	* 동료 객체 - 중재자 객체 중 의사소통. 
		* 이 과정에 감시자 패턴을 적용할 수 있다.
		* 특화된 notification 인터페이스를 만들 수도 있다.
* 관련 패턴
	* 퍼사드 패턴: 퍼사드는 퍼사드 객체 -> 서브시스템의 단방향, 중재자는 양방향
	* 감시자 패턴: 상호 관련된 객체들이 교류하는 방법으로 사용