# 명령(Command) - 객체 행동

* 의도: 요청 자체를 캡슐화 하는 것으로, 서로 다른 요청을 한 사용자를 같은 선상에서 취급할 수 있다. 또한 요청의 대기, 로깅, 되돌리기 등을 구현할 수 있게 한다.
* 다른 이름: 작동(Action), 트랜잭션(Transaction)
* 동기: 요청받은 연산이 무엇인지, 이를 처리할 객체가 누구인지에 대한 아무런 정보 없이 임의의 객체를 보내야 하는 경우가 종종 생긴다. ->  명령을 요청하는 객체와 수행하는 객체를 분리해주고 싶다.
* 활용성
	* 수행할 동작을 객체로 매개변수화 할 때 -> 절차 지향에서의 콜백 함수를 객체지향화 한 것
	* 서로 다른시간에 요청을 명시하고, 저장하고, 실행하고 싶을 때 ->원래의 요청과 다른 생명주기를 가진다.
	* 실행 취소 기능을 지원하고 싶을 때 -> Unexecute() 인터페이스 추가
	* 시스템이 고장났을 때 재적용이 가능하도록 변경 과정에 대한 로깅을 지원하고 싶을 때  -> load()와 store() 인터페이스 추가, 이렇게 저장된 명령을 불러와 다시 실행한다.
	* 기본적인 연산의 조합으로 만든 상위 수준 연산을 써서 시스템을 구조화하고 싶을 때 -> 트랜잭션의 구현
* 구조
  ![Command](/img/Command.JPG)  
* 참여자
	* Command: 연산 수행에 필요한 인터페이스를 선언한다.
	* ConcreteCommand: Receiver 객체와 액션간의 연결성을 정의한다. 또한 처리 객체에 정의된 연산을 호출하도록 Execute를 구현한다.
	* Client: ConcreteCommand 객체를 생성하고 처리 객체로 정의한다.
	* Invoker: 명령어에 처리를 수행할 것을 요청한다.
	* Receiver: 요청에 관련된 연산 수행 방법을 알고 있는 객체
* 협력 방법 
	* 사용자 -> ConcreceCommand 생성후 이를 수신자로 지정
	* Invoker -> ConcreteCommand  저장
	* Invoker ->  command에 정의된 Execute 호출, 취소 가능한 명령어라면 이 때 이전 상태가 ConcreteCommand에 저장된다.
	* ConcreteCommand가 실제 연산을 위해 Receiver객체를 사용한다. 
	![CommandInteraction](/img/CommandInteraction.JPG) 
* 결과
	* 연산을 호출하는 객체와 수행 방법을 구현하는 객체를 분리한다.
	* Command가 일급 클래스이므로 다른 객체와 같은 방식으로 변경 및 확장이 가능하다.
	* 복합 명령을 만들 수 있다.
	* 새로운 Command 객체를 추가할 수 있다.
* 구현
	* 명령이 얼마나 지능적이여야 하는가? -> 수신 객체를 동적으로 발견할 수 있는 능력이 있어야 한다.
	* 취소 및 반복 연산 지원하기 
		* 연산 취소를 위해서는 1) 실제 요청을 처리하는 수신 객체, 2) 연산에 필요한 매개변수 정보, 3) 요청이 처리되어 변하기 전 원래의 값을 저장하고 있어야 한다.
		* 여러번의 취소를 지원하기 위해, 이력(History)를 가지고 있어야 한다.
		* 이력을 저장할 때, Command 객체 자체를 별도로 복사해 유지해야 할 수도 있다.(Command 객체의 상태가 불변이라면 별도로 유지할 필요없다)
	* 취소를 진행하는 도중 오류가 누적되는 것을 피해야 한다. -> 연산 취소 후 제대로 된 상태로 복귀가 되었는지 확인 하는 작업이 필요하다.
	* C++ 템플릿 적용하기 -> 취소가 안되거나, 인자가 필요없는  Command의 경우에 서브클래스 수를 줄여준다.
* 관련 패턴
	* 복합체 패턴: Command의 조합에 적용할 수 있다.
	* 메멘토 패턴: 취소를 처리할 때, 객체 상태를 관리하기 위해 적용할 수 있다.
	* 원형 패턴: Command의  복사가 필요할 때 적용할 수 있다.