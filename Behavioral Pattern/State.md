# 상태(State) - 객체 행동
* 의도: 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 허가하는 것. 이렇가 하면 마치 객체가 자신의 클래스를 바꾸는 것처럼 보인다.
* 다른 이름: 상태 표현 객체(Object for state)
* 동기: 동일한 요청에도 상태에 따라 다르게 동작해야 하는데, 이를 간략화하고 싶다.
* 활용성
	* 객체의 행동이 상태에 따라 달라질 수 있고, 상태에 따라서 런타임에 행동이 바뀌어야 한다.
	* 어떤 연산에 상태에 따른 다중 분기 처리가 많이 들어가 있을 때
* 구조
   ![State](/img/State.JPG)
* 참여자
	* Context: 사용자가 관심 있는 인터페이스를 정의, ConcreteState의 인스턴스를 유지 및 관리
	* State: Context의 각 상태별로 필요한 행동을 캡슐화하여 인터페이스로 정의
	* ConcreteState 서브클래스들: Context의 상태에 따라 처리 될 실제 연산을 구현
* 협력 방법
	* Context는 요청이 오면 이를 ConcreteState 객체로 전달한다.
	* 요청을 전달할 때, Context는 자기 자신을 ConcreteState로 전달한다.
	* Context는 사용자가 사용할 수 있는 기본 인터페이스를 제공한다.
	* Context혹은 ConcreteState 서브 클래스들은 상태 전이 규칙을 알고, 이를 수행해야 한다.
* 결과
	* 상태에 따른 행동을 국소화하고, 서로 다른 상태에 대한 행동을 별도의 객체로 관리한다. -> switch문의 case문을 줄일 수 있다. 이는 클래스가 많아진다는 단점과의 trade-off 관계를 가진다.
	* 상태 전이를 명확하게 만든다.
	* 상태 객체는 공유될 수 있다.
* 구현
	* 누가 상태 전이를 정할 것인가?
		* 고정된 규칙이 있다면 Context에서 할 수도 있다.
		* ConcreteState의 서브클래스들이 자신 다음 상태와 그 타이밍을 전하는 게 더 유연하고 적절한 방법이다. -> Context에 별도의 인터페이스가 필요하고, ConcreteState간에 종속성이 생길 수 있다.
	*  테이블 기반의 대안 -> 테이블에 처리 가능한 입력과 다음 상태를 저장해놓고, 테이블을 탐색하는 것으로 조건문을 대체한다.
		* 장점: 규칙성 -> 프로그램을 바꾸지 않고 테이블만 바꾸면 새로운 전이 기준을 쉽게 만들 수 있다.
		* 단점
			* 간혹 (가상) 함수 호출보다 비효율적일 때가 있다.
			* 전이 기준이 테이블에 맞춰지면서 불명확해지고 이해하기가 어려워진다.
			* 전이에 따른 처리 동작을 추가하기 어렵다.
	* 상태 객체의 생성과 소멸
		* 필요할 때만 만들고, 필요 없어지면 버린다 - 실행하기 전까지 판단이 안서거나, 자주 안바뀌거나, State객체가 크다면 유용하다.
		* 미리 만들어 놓고, 계속 사용한다 - 상태변화가 수시로 일어날 때 유용하지만, Context 클래스가 모든 상태에 대한 참조자를 계속 관리해야 한다.
	* 동적 상속을 이용하는 방법 -> 일부 언어에서만 사용 가능한 테크닉
* 관련 패턴
	* 플라이급 패턴: 상태 객체의 공유 시점과 공유 방법을 정의하는 데 적용한다.
	* 단일체 패턴: 상태 객체가 하나만 존재하는 경우