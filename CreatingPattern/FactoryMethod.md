#  팩토리 메소드(Factory Method) - 클래스 생성(Class Creational)
* 의도 : 객체 생성 인터페이스는 정의하지만, 실제 인스턴스의 타입은 서브클래스가 결정한다.
* 다른 이름 : 가상 생성자(Virtual Constructor)
* 동기 : 추상 클래스의 인터페이스만 가지고, 실제로 필요한 구체 클래스의 인스턴스를 만들고 싶다.
* 활용성
	* 어떤 클래스가 자신이 생성해야 하는 객체의 클래스를 예측할 수 없을 때
	* 생성할 객체를 기술하는 책임을 자신의 서브클래스가 지정했으면 할 때
	* 객체 생성의 책임을 몇 개의 보조 서브클래스 가운데 하나에게 위임하고, 어떤 서브클래스가 위임자인지에 대한 정보를 국소화시키고 싶을 때
* 구조
  ![factoryMethod](/img/FactoryMethod.JPG) 
* 참여자
	* Product : 팩토리 메소드가 생성하는 객체의 인터페이스를 정의
	* ConcreteProduct : Product 클래스에 정의된 인터페이스를 실제로 구현
	* Creator : Product 타입의 객체를 반환하는 팩토리 메소드를 선언한다. 구현도 하는데 이때는 ConcreteProduct를 반환한다. -> 최소한의 기본 구현을 제공
	* ConcreteCreator : 팩토리 메소드를 재정의하여  ConcreteProduct의 인스턴스를 반환한다.
* 협력방법
	* 서브클래스를 통해 실제 필요한 팩토리 메소드를 정의하여 적절한  ConcreteProduct의 인스턴스를 반환하도록 한다.
* 결과
	1. ConcreteProduct가 하나여도 Creator를 서브클래싱하는 번거로운 과정이 필요하다.
	2. 서브클래스에 대한 훅(Hook) 메소드를 제공한다.
	3. 병렬적인 클래스 계통을 연결한다.
* 구현
	* 구현 방법이 두가지다.
		1. Creator를 추상 클래스로 하고, 팩토리 메소드에 기본 구현을 제공하지 않는다. -> 구현을 서브클래스에 일임하기 때문에, 어떤 클래스가 나올 지 예측할 수 없다.
		2. Creator를 구체 클래스로 하고, 팩토리 메소드에 기본 구현을 제공한다. -> 팩토리 메소드의 유연성을 제공해 줄 수 있다.
	* 팩토리 메서드를 매개변수화한다. -> 서브클래싱하면, 쉽게 이를 확장하거나 변경할 수 있다.
	* 언어마다 구현이 조금 다를 수 있다. 
	* 템플릿을 사용하면, 서브클래싱을 피할 수 있다.
	* 명명 규칙을 따르는 것도 중요하다.
* 관련 패턴
	* 추상 팩토리
	* 템플릿 메소드 패턴
	* 원형 패턴