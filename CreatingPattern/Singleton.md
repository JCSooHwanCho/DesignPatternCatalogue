# 단일체(Singleton)
* 의도 : 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적 접근점을 제공한다.
* 동기 : 오직 하나의 인스턴스만 존재해야 하고, 이 클래스에 접근하는 방법을 제공해야 한다.
* 활용성
	* 클래스의 인스턴스가 오직 하나여야 하고, 하나의 접근점으로 모든 사용자가 접근해야할 때
	* 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드 수정 없이 이를 사용하여야 한다.
* 구조
   ![Singleton](/img/Singleton.JPG)
* 참여자
	* Singleton : Instance() 연산을 정의하여, 유일한 인스턴스로 접근할 수 있도록 한다. -> 클래스 연산이다.
* 협력방법 : 사용자는 Singleton 클래스에 정의된 Instance() 연산을 통해서 유일하게 생성되는 단일체 인스턴스에 접근할 수 있다.
* 결과
	* 유일하게 존재하는 인스턴스로의 접근을 통제한다.
	* 이름공간을 좁힌다 -> 전역변수의 관리의 어려움을 해결해준다.
	* 연산 및 표현의 정제를 허용한다. -> 서브클래싱
	* 인스턴스의 개수 변경이 자유롭다
	* 클래스 연산을 사용하는 것보다 훨씬 유연한다. -> 인스턴스 개수 변경 요구에서 자유롭지 않고, C++에서는 오버라이드가 안된다.
* 구현
	* 인스턴스가 유일함을 보장해야 한다.
		* 사용자가 직접 생성자를 호출하게 해서는 안된다.
		* c++의 구현에서 주의할 점
			* 정적 객체의유일한 인스턴스만 선언되는 것을 언어 차원에서 보장할 수 없다.
			* 정적 객체로 선언하면, 이후에 값을 수정할 수 없다 -> 정적 메소드는 인스턴스의 값을 변경할 수 없기 때문
			* 전역 객체로 하면, 언제 호출되는 지에 대한 명확한 순서가 정의되어 있지 않아 오류가 발생할 가능성이 있다. 
	* Singleton 클래스를 서브클래싱 한다. -> 원래  Singleton 객체를 참조하던 부분에서 서브클래스의 인스턴스를 사용하도록 해야한다.
		* Instance() 연산을 사용할 때 어떤 것을 쓸 지 고른다.
		* Instance()를 서브클래스에서 구현한다.
		* 단일체에 대한 레지스트리를 사용한다.
			* public Register(name, SingletonType)
			* protected LookUp(name)
			* private List<NameSingletonPair> registry
	* 관련 패턴
		* 추상 팩토리, 빌더, 원형 패턴